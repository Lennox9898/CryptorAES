#!/usr/bin/env python3
"""
cryptor_gui_kyber.py
A cleaned-up CLI helper for file encryption/decryption using Argon2id-derived keys,
AES-256-GCM streaming, ChaCha20-Poly1305, and optional Kyber/X25519 hybrid key
exchange (via python-oqs when available).

Dependencies:
  pip install cryptography argon2_cffi tqdm
  Optional: pip install oqs  (requires liboqs/native libs; feature disabled if not installed)
"""

import argparse
import base64
import importlib
import json
import logging
import os
import secrets
import struct
from pathlib import Path

from tqdm import tqdm

from cryptography.exceptions import InvalidTag
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.asymmetric import x25519
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.primitives.ciphers.aead import ChaCha20Poly1305
from cryptography.hazmat.primitives.kdf.hkdf import HKDF

from argon2.low_level import Type, hash_secret_raw

# Optional python-oqs support (without try/except around imports)
oqs = None
_oqs_spec = importlib.util.find_spec("oqs")
OQS_AVAILABLE = False
if _oqs_spec is not None:
    oqs = importlib.import_module("oqs")
    OQS_AVAILABLE = True

MAGIC = "CRYPTOR_PQC_V2"
SALT_SIZE = 16
NONCE_SIZE = 12  # for AES-GCM / ChaCha20-Poly1305 usage
ARGON2_TIME = 3
ARGON2_MEMORY_KIB = 64 * 1024
ARGON2_PARALLELISM = 4
CHUNK = 64 * 1024
TAG_SIZE = 16
BACKEND = default_backend()

logging.basicConfig(level=logging.INFO, format="%(levelname)s: %(message)s")
logger = logging.getLogger("cryptor")


def derive_argon2(
    password: bytes,
    salt: bytes,
    time: int = ARGON2_TIME,
    mem_kib: int = ARGON2_MEMORY_KIB,
    parallelism: int = ARGON2_PARALLELISM,
    length: int = 32,
) -> bytes:
    """Return a raw Argon2id-derived key (requires argon2_cffi)."""

    return hash_secret_raw(
        secret=password,
        salt=salt,
        time_cost=time,
        memory_cost=mem_kib,
        parallelism=parallelism,
        hash_len=length,
        type=Type.ID,
    )


def hkdf(shared: bytes, length: int = 32, info: bytes = b"cryptor-pqc") -> bytes:
    return HKDF(
        algorithm=hashes.SHA256(),
        length=length,
        salt=None,
        info=info,
        backend=BACKEND,
    ).derive(shared)


def write_file_with_header(path: str, header: dict, ciphertext: bytes, tag: bytes = b"") -> None:
    hdr_json = json.dumps(header).encode("utf-8")
    with open(path, "wb") as f:
        f.write(struct.pack(">I", len(hdr_json)))
        f.write(hdr_json)
        f.write(ciphertext)
        if tag:
            f.write(tag)


def read_header_and_body(path: str) -> tuple[dict, bytes]:
    with open(path, "rb") as f:
        raw = f.read(4)
        if len(raw) != 4:
            raise ValueError("Not a valid file (missing header).")
        (hlen,) = struct.unpack(">I", raw)
        hdr = f.read(hlen)
        header = json.loads(hdr.decode("utf-8"))
        body = f.read()
    return header, body


def encrypt_stream_aes_gcm(inpath: str, outpath: str, key: bytes, header: dict) -> None:
    nonce = secrets.token_bytes(NONCE_SIZE)
    header["alg"] = "AES-256-GCM"
    header["nonce"] = base64.b64encode(nonce).decode()
    cipher = Cipher(algorithms.AES(key), modes.GCM(nonce), backend=BACKEND)
    encryptor = cipher.encryptor()

    hdr_json = json.dumps(header).encode("utf-8")
    total = os.path.getsize(inpath)
    with open(outpath, "wb") as fout, open(inpath, "rb") as fin, tqdm(
        total=total, unit="B", unit_scale=True, desc="Encrypting"
    ) as pbar:
        fout.write(struct.pack(">I", len(hdr_json)))
        fout.write(hdr_json)
        for chunk in iter(lambda: fin.read(CHUNK), b""):
            ct = encryptor.update(chunk)
            if ct:
                fout.write(ct)
            pbar.update(len(chunk))
        encryptor.finalize()
        fout.write(encryptor.tag)


def decrypt_stream_aes_gcm(inpath: str, outpath: str, key: bytes) -> None:
    header, body = read_header_and_body(inpath)
    if header.get("alg") != "AES-256-GCM":
        raise ValueError("Wrong algorithm in file")
    nonce = base64.b64decode(header["nonce"])
    tag = body[-TAG_SIZE:]
    ciphertext = body[:-TAG_SIZE]
    cipher = Cipher(algorithms.AES(key), modes.GCM(nonce, tag), backend=BACKEND)
    decryptor = cipher.decryptor()

    total = len(ciphertext)
    with open(outpath, "wb") as fout, tqdm(
        total=total, unit="B", unit_scale=True, desc="Decrypting"
    ) as pbar:
        idx = 0
        while idx < total:
            chunk = ciphertext[idx : idx + CHUNK]
            pt = decryptor.update(chunk)
            if pt:
                fout.write(pt)
            idx += len(chunk)
            pbar.update(len(chunk))
        try:
            decryptor.finalize()
        except InvalidTag:
            fout.close()
            os.remove(outpath)
            raise InvalidTag("Authentication failed")


def encrypt_chacha(inpath: str, outpath: str, key: bytes, header: dict) -> None:
    header["alg"] = "ChaCha20-Poly1305"
    nonce = secrets.token_bytes(12)
    header["nonce"] = base64.b64encode(nonce).decode()
    aead = ChaCha20Poly1305(key)
    with open(inpath, "rb") as f:
        pt = f.read()
    ct = aead.encrypt(nonce, pt, None)
    write_file_with_header(outpath, header, ct)


def decrypt_chacha(inpath: str, outpath: str, key: bytes) -> None:
    header, body = read_header_and_body(inpath)
    if header.get("alg") != "ChaCha20-Poly1305":
        raise ValueError("Wrong algorithm in file")
    nonce = base64.b64decode(header["nonce"])
    aead = ChaCha20Poly1305(key)
    pt = aead.decrypt(nonce, body, None)
    with open(outpath, "wb") as f:
        f.write(pt)


# Kyber envelope helpers (using python-oqs if available)
def kyber_encapsulate(recipient_pub_b64: str, kem_name: str = "Kyber768") -> tuple[bytes, bytes]:
    if not OQS_AVAILABLE:
        raise RuntimeError("python-oqs not available")
    rec_raw = base64.b64decode(recipient_pub_b64)
    with oqs.KeyEncapsulation(kem_name) as kem:
        ct, shared = kem.encap(rec_raw)
    return ct, shared


def kyber_decapsulate(kem_ct_b64: str, recipient_priv_b64: str, kem_name: str = "Kyber768") -> bytes:
    if not OQS_AVAILABLE:
        raise RuntimeError("python-oqs not available")
    ct = base64.b64decode(kem_ct_b64)
    sk_raw = base64.b64decode(recipient_priv_b64)
    with oqs.KeyEncapsulation(kem_name) as kem:
        shared = kem.decap(ct, sk_raw)
    return shared


# X25519 helpers
def x25519_shared_with_recipient(recipient_pub_b64: str) -> tuple[bytes, bytes]:
    rec_raw = base64.b64decode(recipient_pub_b64)
    recip_pub = x25519.X25519PublicKey.from_public_bytes(rec_raw)
    eph_priv = x25519.X25519PrivateKey.generate()
    eph_pub = eph_priv.public_key().public_bytes(
        encoding=serialization.Encoding.Raw, format=serialization.PublicFormat.Raw
    )
    shared = eph_priv.exchange(recip_pub)
    return eph_pub, shared


def x25519_decompose_shared(eph_pub_b64: str, recipient_priv_b64: str) -> bytes:
    eph_pub = base64.b64decode(eph_pub_b64)
    priv_raw = base64.b64decode(recipient_priv_b64)
    priv = x25519.X25519PrivateKey.from_private_bytes(priv_raw)
    return priv.exchange(x25519.X25519PublicKey.from_public_bytes(eph_pub))


# Keyfile generators
def generate_keyfile(path: str, bits: int = 256) -> None:
    key = secrets.token_bytes(bits // 8)
    with open(path, "wb") as f:
        f.write(key)
    os.chmod(path, 0o600)


def kyber_generate_keypair(kem_name: str = "Kyber768") -> tuple[str, str]:
    if not OQS_AVAILABLE:
        raise RuntimeError("python-oqs not available")
    with oqs.KeyEncapsulation(kem_name) as kem:
        pub, priv = kem.generate_keypair()
    return base64.b64encode(pub).decode(), base64.b64encode(priv).decode()


def x25519_generate_keypair() -> tuple[str, str]:
    priv = x25519.X25519PrivateKey.generate()
    pub = priv.public_key()
    priv_raw = priv.private_bytes(
        encoding=serialization.Encoding.Raw,
        format=serialization.PrivateFormat.Raw,
        encryption_algorithm=serialization.NoEncryption(),
    )
    pub_raw = pub.public_bytes(
        encoding=serialization.Encoding.Raw, format=serialization.PublicFormat.Raw
    )
    return base64.b64encode(pub_raw).decode(), base64.b64encode(priv_raw).decode()


def build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(description="Cryptor AES/Kyber helper")
    sub = parser.add_subparsers(dest="command", required=True)

    keygen_p = sub.add_parser("gen-keyfile", help="Generate a random keyfile")
    keygen_p.add_argument("output", type=Path, help="Destination path for the keyfile")
    keygen_p.add_argument("--bits", type=int, default=256, choices=(256, 512), help="Key size in bits")

    sub.add_parser("gen-x25519-pair", help="Generate an X25519 keypair (base64)")
    sub.add_parser("gen-kyber-pair", help="Generate a Kyber keypair (base64)")

    encrypt_p = sub.add_parser("encrypt", help="Encrypt a file")
    encrypt_p.add_argument("input", type=Path)
    encrypt_p.add_argument("output", type=Path)
    encrypt_p.add_argument("--alg", choices=("AES-256-GCM", "ChaCha20-Poly1305"), default="AES-256-GCM")
    key_mode = encrypt_p.add_mutually_exclusive_group(required=True)
    key_mode.add_argument("--passphrase", help="Passphrase for Argon2id derivation")
    key_mode.add_argument("--keyfile", type=Path, help="Use raw key bytes from a file")
    key_mode.add_argument("--kyber-pub", help="Recipient Kyber public key (base64)")
    encrypt_p.add_argument("--x25519-pub", help="Recipient X25519 public key for hybrid mode")

    decrypt_p = sub.add_parser("decrypt", help="Decrypt a file")
    decrypt_p.add_argument("input", type=Path)
    decrypt_p.add_argument("output", type=Path)
    decrypt_p.add_argument("--passphrase", help="Passphrase for Argon2id derivation")
    decrypt_p.add_argument("--keyfile", type=Path, help="Use raw key bytes from a file")
    decrypt_p.add_argument("--kyber-priv", help="Recipient Kyber private key (base64)")
    decrypt_p.add_argument("--x25519-priv", help="Recipient X25519 private key for hybrid mode")

    return parser


def prepare_encrypt_key(args: argparse.Namespace) -> tuple[bytes, dict]:
    header: dict[str, object] = {"magic": MAGIC, "version": 2}
    key: bytes
    if args.passphrase:
        salt = secrets.token_bytes(SALT_SIZE)
        header["kdf"] = "argon2id"
        header["salt"] = base64.b64encode(salt).decode()
        header["argon2"] = {
            "time": ARGON2_TIME,
            "mem_kib": ARGON2_MEMORY_KIB,
            "parallelism": ARGON2_PARALLELISM,
        }
        key = derive_argon2(args.passphrase.encode("utf-8"), salt)
    elif args.keyfile:
        key = args.keyfile.read_bytes()
        header["kdf"] = "raw"
    else:
        if not OQS_AVAILABLE:
            raise RuntimeError("python-oqs (liboqs) not available for Kyber mode")
        kem_alg = "Kyber768"
        kem_ct, shared_kem = kyber_encapsulate(args.kyber_pub, kem_alg)
        header.update({"kdf": "kyber", "kem_alg": kem_alg, "kem_ct": base64.b64encode(kem_ct).decode()})
        if args.x25519_pub:
            eph_pub_x, shared_x = x25519_shared_with_recipient(args.x25519_pub)
            header["x25519_ephemeral_pub"] = base64.b64encode(eph_pub_x).decode()
            header["kdf"] = "kyber+x25519"
            combined = shared_kem + shared_x
            key = hkdf(combined, info=b"kyber+x25519")
        else:
            key = hkdf(shared_kem)
    return key, header


def prepare_decrypt_key(header: dict, args: argparse.Namespace) -> bytes:
    kdf = header.get("kdf")
    if kdf == "argon2id":
        if not args.passphrase:
            raise ValueError("Passphrase required for Argon2id-derived file")
        salt = base64.b64decode(header["salt"])
        return derive_argon2(args.passphrase.encode("utf-8"), salt)
    if kdf == "raw":
        if not args.keyfile:
            raise ValueError("Keyfile required for raw-key file")
        return Path(args.keyfile).read_bytes()
    if kdf not in ("kyber", "kyber+x25519"):
        raise ValueError("Unknown KDF/mode in file")
    if not OQS_AVAILABLE:
        raise RuntimeError("python-oqs not available; cannot decapsulate Kyber")
    if not args.kyber_priv:
        raise ValueError("Kyber private key required for this file")

    kem_alg = header.get("kem_alg", "Kyber768")
    kem_ct_b64 = header["kem_ct"]
    shared_kem = kyber_decapsulate(kem_ct_b64, args.kyber_priv, kem_alg)
    if kdf == "kyber+x25519":
        if not args.x25519_priv:
            raise ValueError("X25519 private key required for hybrid decryption")
        eph_pub_b64 = header.get("x25519_ephemeral_pub")
        if not eph_pub_b64:
            raise ValueError("Missing ephemeral X25519 public key in header")
        shared_x = x25519_decompose_shared(eph_pub_b64, args.x25519_priv)
        return hkdf(shared_kem + shared_x, info=b"kyber+x25519")
    return hkdf(shared_kem)


def handle_encrypt(args: argparse.Namespace) -> None:
    key, header = prepare_encrypt_key(args)
    if args.alg == "AES-256-GCM":
        encrypt_stream_aes_gcm(str(args.input), str(args.output), key, header)
    else:
        if len(key) != 32:
            raise ValueError("ChaCha20-Poly1305 requires a 32-byte key")
        encrypt_chacha(str(args.input), str(args.output), key, header)
    logger.info(
        "Encrypted %s -> %s (kdf=%s, alg=%s)",
        args.input,
        args.output,
        header.get("kdf"),
        header.get("alg"),
    )


def handle_decrypt(args: argparse.Namespace) -> None:
    header, _ = read_header_and_body(str(args.input))
    key_dec = prepare_decrypt_key(header, args)
    if header.get("alg") == "AES-256-GCM":
        decrypt_stream_aes_gcm(str(args.input), str(args.output), key_dec)
    elif header.get("alg") == "ChaCha20-Poly1305":
        decrypt_chacha(str(args.input), str(args.output), key_dec)
    else:
        raise ValueError("Unknown algorithm in file")
    logger.info("Decrypted %s -> %s (kdf=%s)", args.input, args.output, header.get("kdf"))


def main() -> None:
    parser = build_parser()
    args = parser.parse_args()

    if args.command == "gen-keyfile":
        generate_keyfile(str(args.output), args.bits)
        logger.info("Keyfile written to %s", args.output)
    elif args.command == "gen-x25519-pair":
        pub, priv = x25519_generate_keypair()
        print("X25519 public:", pub)
        print("X25519 private:", priv)
    elif args.command == "gen-kyber-pair":
        if not OQS_AVAILABLE:
            raise RuntimeError("python-oqs (liboqs) not available")
        pub, priv = kyber_generate_keypair()
        print("Kyber public:", pub)
        print("Kyber private:", priv)
    elif args.command == "encrypt":
        handle_encrypt(args)
    elif args.command == "decrypt":
        handle_decrypt(args)


if __name__ == "__main__":
    main()
